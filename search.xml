<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SPOJ2666-QTREE4</title>
      <link href="/2019/09/22/SPOJ2666-QTREE4/"/>
      <url>/2019/09/22/SPOJ2666-QTREE4/</url>
      
        <content type="html"><![CDATA[<p>这题是可以点分治或LCT作的。。但这里讲边分治的做法。。</p><p>和点分治类似，边分治利用一条树上路径要吗经过一条边，要么不经过。而不经过的路径必然会在一次分治中变为经过的。</p><p>我们找到一条中心边，边左边和边右边分别建一个大根堆。左边的堆中存储边的左子树中白点的深度，右边的堆储存右边的。</p><p>当发生颜色反转时，若为黑点转白点，则去掉标记，并将点压入相应的堆中。若为白点转为黑点，则将其打上标记。</p><p>统计时，先不断弹左右堆顶，直到堆顶没有标记或堆空。然后用左堆顶值、右堆顶值和(左堆顶值+右堆顶值+中心边长度)三者的最大值更新答案。</p><p>为方便边分治，我们使每个点的度数不大于$3$，即转为一棵二叉树。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>, MAXE = <span class="number">4e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, w, nxt, pre;</span><br><span class="line">&#125; edge[MAXE], _edge[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], _head[MAXN], tot, _tot, tail[MAXN], mark[MAXN], size[MAXN], n,</span><br><span class="line">    _n, cnt, rt, midedge, maxv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) &#123;</span><br><span class="line">  _edge[_tot].v = v, _edge[_tot].w = w, _edge[_tot].nxt = _head[u],</span><br><span class="line">  _head[u] = _tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tot].v = v, edge[tot].w = w, edge[tot].nxt = head[u], head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head[u] == i)</span><br><span class="line">    head[u] = edge[i].nxt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    edge[edge[i].pre].nxt = edge[i].nxt;</span><br><span class="line">  <span class="keyword">if</span> (tail[u] == i)</span><br><span class="line">    tail[u] = edge[i].pre;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    edge[edge[i].nxt].pre = edge[i].pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> father = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = _head[u]; ~i; i = _edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = _edge[i].v, w = _edge[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (father == <span class="number">0</span>)</span><br><span class="line">      add(u, v, w), add(v, u, w), father = u, build(v, u);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      mark[++n] = <span class="number">0</span>, add(n, father, <span class="number">0</span>), add(father, n, <span class="number">0</span>), father = n,</span><br><span class="line">      add(v, father, w), add(father, v, w), build(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(tail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(tail));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; ~j; j = edge[j].nxt)</span><br><span class="line">      edge[j].pre = tail[i], tail[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, dis;</span><br><span class="line">  point() &#123;&#125;</span><br><span class="line">  point(<span class="keyword">int</span> _u, <span class="keyword">int</span> _dis) &#123;</span><br><span class="line">    u = _u;</span><br><span class="line">    dis = _dis;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> point &amp;_A) <span class="keyword">const</span> &#123; <span class="keyword">return</span> dis &lt; _A.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> rt, midlen, ans, ls, rs;</span><br><span class="line">  priority_queue&lt;point&gt; q;</span><br><span class="line">&#125; t[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_size</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line">  _add(u, rt, dir);</span><br><span class="line">  <span class="keyword">if</span> (mark[u])</span><br><span class="line">    t[rt].q.push(point(u, dir));</span><br><span class="line">  size[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v, w = edge[i].w;</span><br><span class="line">    <span class="keyword">if</span> (v == fa)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    dfs_size(v, u, dir + w), size[u] += size[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_midedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (max(size[u], size[t[rt].rt] - size[u]) &lt; maxv)</span><br><span class="line">    maxv = max(size[u], size[t[rt].rt] - size[u]), midedge = fa;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">if</span> (i != (fa ^ <span class="number">1</span>))</span><br><span class="line">      dfs_midedge(v, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">  t[rt].ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !t[rt].q.empty() &amp;&amp; mark[t[rt].q.top().u] == <span class="number">0</span>;)</span><br><span class="line">    t[rt].q.pop();</span><br><span class="line">  <span class="keyword">int</span> ls = t[rt].ls, rs = t[rt].rs;</span><br><span class="line">  <span class="keyword">if</span> (ls == <span class="number">0</span> &amp;&amp; rs == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mark[t[rt].rt])</span><br><span class="line">      t[rt].ans = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t[ls].ans &gt; t[rt].ans)</span><br><span class="line">      t[rt].ans = t[ls].ans;</span><br><span class="line">    <span class="keyword">if</span> (t[rs].ans &gt; t[rt].ans)</span><br><span class="line">      t[rt].ans = t[rs].ans;</span><br><span class="line">    <span class="keyword">if</span> (!t[ls].q.empty() &amp;&amp; !t[rs].q.empty())</span><br><span class="line">      t[rt].ans =</span><br><span class="line">          max(t[rt].ans, t[ls].q.top().dis + t[rs].q.top().dis + t[rt].midlen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  rt = id, maxv = n, midedge = <span class="number">-1</span>, t[id].rt = u;</span><br><span class="line">  dfs_size(u, <span class="number">0</span>, <span class="number">0</span>), dfs_midedge(u, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (~midedge) &#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = edge[midedge].v, p2 = edge[midedge ^ <span class="number">1</span>].v;</span><br><span class="line">    t[id].midlen = edge[midedge].w, t[id].ls = ++cnt, t[id].rs = ++cnt,</span><br><span class="line">    del(p1, midedge ^ <span class="number">1</span>), del(p2, midedge), dfs(t[id].ls, p1),</span><br><span class="line">    dfs(t[id].rs, p2);</span><br><span class="line">  &#125;</span><br><span class="line">  pushup(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  mark[u] ^= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = _head[u]; ~i; i = _edge[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = _edge[i].v, w = _edge[i].w;</span><br><span class="line">    <span class="keyword">if</span> (mark[u] == <span class="number">1</span>)</span><br><span class="line">      t[v].q.push(point(u, w));</span><br><span class="line">    pushup(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(_head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(_head)), <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; _n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), _add(u, v, w), _add(v, u, w);</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)), n = _n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    mark[i] = <span class="number">1</span>;</span><br><span class="line">  build(<span class="number">1</span>, <span class="number">0</span>), get_pre(), <span class="built_in">memset</span>(_head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(_head)), _tot = <span class="number">0</span>,</span><br><span class="line">                                                            dfs(cnt = <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> m, x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (; m; --m) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">    <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'A'</span>)</span><br><span class="line">      <span class="keyword">if</span> (t[<span class="number">1</span>].ans == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"They have disappeared.\n"</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[<span class="number">1</span>].ans);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), update(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPOJ1825-FTOUR2</title>
      <link href="/2019/09/22/SPOJ1825-FTOUR2/"/>
      <url>/2019/09/22/SPOJ1825-FTOUR2/</url>
      
        <content type="html"><![CDATA[<p>我们知道，树上两个点的LCA要么是当前根节点，要么不是。。所以两个点间的最短路径要么经过当前根节点，要么在一棵当前根节点的子树中。。</p><p>考虑点分治，于是在原来同一子树中的两个点必然在一次分治中变为路径经过当前根节点的两个点。</p><p><del>点分治标准开头(雾</del></p><a id="more"></a><p>对于路径经过当前根节点的点。从当前根到点$i$的路径上经过的拥挤点数为$num_i$，路径长度为$d_i$。求这两个值简单$dfs$即可。</p><p>合并我们采用启发式合并以保证复杂度。首先，我们按当前根子树的最大深度升序将子树排列。</p><p>当我们处理到当前根的第$T$个子树时，记录：以当前根为一端点，前$(T-1)$棵当前根的子树中，经过$s(0\le s\le K)$个拥挤点的最长路径长度为$maxv_s$。</p><p>于是，当我们处理到第$T$棵子树的节点$u$时:</p><script type="math/tex; mode=display">ans=max(ans,(maxv_s+d_u)[num_u+s\le K])</script><p>合并时也要处理$maxv$。将所有节点按$num$倒序处理，然后按用$maxv_{i-1}$更新$maxv_i$，以找到上文中的$maxv_s$。然后用子树$T$来更新$maxv$。求出子树$T$中的每组相等的$num_i$中最大的$d_i$，记为$dist_{num_i}$，然后用$dist$更新$maxv$。</p><p>最后，显然，用树的重心作为树根为最优。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next ___________________________________________________________________</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">400005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, m, flag[MAXN], head[MAXN], to[MAXN], next[MAXN], w[MAXN],</span><br><span class="line">    tot = <span class="number">1</span>, dist[MAXN], tmp, f[MAXN], root, size[MAXN], sum, vis[MAXN], ans,</span><br><span class="line">    d[MAXN], num[MAXN], maxn, maxv[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  w[tot] = z, to[tot] = y, next[tot] = head[x], head[x] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  size[now] = <span class="number">1</span>, f[now] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = next[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (v == fa || vis[v])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    getroot(v, now), size[now] += size[v], f[now] = max(f[now], size[v]);</span><br><span class="line">  &#125;</span><br><span class="line">  f[now] = max(f[now], sum - size[now]);</span><br><span class="line">  <span class="keyword">if</span> (f[now] &lt; f[root])</span><br><span class="line">    root = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getdep</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  maxn = max(maxn, num[now]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = next[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (v == fa || vis[v])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    d[v] = d[now] + w[i], num[v] = num[now] + flag[v], getdep(v, now);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dist[num[now]] = max(dist[num[now]], d[now]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = next[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (v == fa || vis[v])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    getmax(v, now);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">  vis[now] = <span class="number">1</span>, e.clear();</span><br><span class="line">  <span class="keyword">if</span> (flag[now])</span><br><span class="line">    k--;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = next[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (vis[v])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    num[v] = flag[v], d[v] = w[i], maxn = <span class="number">0</span>, getdep(v, now),</span><br><span class="line">    e.push_back(make_pair(maxn, v));</span><br><span class="line">  &#125;</span><br><span class="line">  sort(e.begin(), e.end());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.size(); i++) &#123;</span><br><span class="line">    getmax(e[i].second, now);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = e[i].first; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (res + <span class="number">1</span> + j &lt;= k &amp;&amp; res + <span class="number">1</span> &lt;= e[i - <span class="number">1</span>].first)</span><br><span class="line">          res++, maxv[res] = max(maxv[res], maxv[res - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (res + j &lt;= k)</span><br><span class="line">          ans = max(ans, maxv[res] + dist[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != e.size() - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= e[i].first; j++)</span><br><span class="line">        maxv[j] = max(maxv[j], dist[j]), dist[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= e[i].first; j++)</span><br><span class="line">        maxv[j] = dist[j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag[now])</span><br><span class="line">    k++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = next[i]) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (vis[v])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    root = <span class="number">0</span>, f[<span class="number">0</span>] = sum = size[v];</span><br><span class="line">    getroot(v, <span class="number">0</span>), solve(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), flag[x] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">      tmp = w;</span><br><span class="line">    add(u, v, w), add(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span> &amp;&amp; k &gt;= m)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp), <span class="number">0</span>;</span><br><span class="line">  f[<span class="number">0</span>] = sum = n, getroot(<span class="number">1</span>, <span class="number">0</span>), solve(root), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ1741-Tree</title>
      <link href="/2019/09/22/POJ1741-Tree/"/>
      <url>/2019/09/22/POJ1741-Tree/</url>
      
        <content type="html"><![CDATA[<p>我们知道，树上两个点的LCA要么是当前根节点，要么不是。。所以两个点间的最短路径要么经过当前根节点，要么在一棵当前根节点的子树中。。</p><p>考虑点分治，于是在原来同一子树中的两个点必然在一次分治中变为路径经过当前根节点的两个点。</p><a id="more"></a><p>处理路径经过当前根节点的两个点的情况。对于当前树，每个节点(根节点除外)记录深度$dep_i$（根节点深度为$0$）和除当前根节点外的最远祖先$fa_i$。。</p><p>于是有：</p><script type="math/tex; mode=display">\sum [fa_i\ne fa_j \land dep_i+dep_j \le K]</script><p>显然，式子等于:</p><script type="math/tex; mode=display">\sum [dep_i+dep_j\le K]-\sum[fa_i=fa_j\land dep_i+dep_j\le K]</script><p>于是可以这样解决:</p><p>在当前树中，将$dep$排序，用$l$表示左指针，$r$表示右指针，$l$从左向右遍历。如果$dep_l+dep_r\le k$，则点对$(l,t)(i&lt;t\le r)$都符合题意，于是将$r-l$加入答案中，并且$l$++；否则$r$—。</p><p>需要注意的是链的情况。。时间复杂度会退化成$O(N^2)$。。我们可以将重心作为根，以保证复杂度为$O(Nlog^2N)$</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, l;</span><br><span class="line">  edge(<span class="keyword">int</span> v_, <span class="keyword">int</span> l_) : v(v_), l(l_)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dep;</span><br><span class="line"><span class="keyword">int</span> n, k, dist[MAXN], vis[MAXN], f[MAXN], root, ans, s[MAXN], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  s[now] = <span class="number">1</span>, f[now] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[now].size(); i++) &#123;</span><br><span class="line">    u = g[now][i].v;</span><br><span class="line">    <span class="keyword">if</span> (u != fa &amp;&amp; !vis[u])</span><br><span class="line">      getroot(u, now), s[now] += s[u], f[now] = max(f[now], s[u]);</span><br><span class="line">  &#125;</span><br><span class="line">  f[now] = max(f[now], tot - s[now]);</span><br><span class="line">  <span class="keyword">if</span> (f[now] &lt; f[root])</span><br><span class="line">    root = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getdep</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  dep.push_back(dist[now]), s[now] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[now].size(); i++) &#123;</span><br><span class="line">    u = g[now][i].v;</span><br><span class="line">    <span class="keyword">if</span> (u != fa &amp;&amp; !vis[u])</span><br><span class="line">      dist[u] = dist[now] + g[now][i].l, getdep(u, now), s[now] += s[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  dep.clear(), dist[now] = len;</span><br><span class="line">  getdep(now, <span class="number">0</span>), sort(dep.begin(), dep.end());</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, r = dep.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    <span class="keyword">if</span> (dep[l] + dep[r] &lt;= k)</span><br><span class="line">      cnt += r - l, l++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      r--;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  ans += calc(now, <span class="number">0</span>), vis[now] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[now].size(); i++) &#123;</span><br><span class="line">    u = g[now][i].v;</span><br><span class="line">    <span class="keyword">if</span> (!vis[u])</span><br><span class="line">      ans -= calc(u, g[now][i].l), f[<span class="number">0</span>] = tot = s[u], root = <span class="number">0</span>, getroot(u, <span class="number">0</span>),</span><br><span class="line">                                   work(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n &amp;&amp; !k)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">      g[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> u, v, l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;l), g[u].push_back(edge(v, l)),</span><br><span class="line">          g[v].push_back(edge(u, l));</span><br><span class="line">    f[<span class="number">0</span>] = n, root = <span class="number">0</span>, tot = n;</span><br><span class="line">    getroot(<span class="number">1</span>, <span class="number">0</span>), ans = <span class="number">0</span>, work(root), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COCI2014/2015#3-KAMIONI</title>
      <link href="/2019/09/22/COCI2014-2015-3-KAMIONI/"/>
      <url>/2019/09/22/COCI2014-2015-3-KAMIONI/</url>
      
        <content type="html"><![CDATA[<p>难得的没人做的水紫题。。</p><p>我的做法：</p><p>首先我们应该将每一辆车的转折点按照发生时间来排序。将所有不重复的查询都保存在拐点少的那个的名下。然后枚举每一个拐点就可以了。</p><a id="more"></a><p>这里是官方题解：</p><ol><li><p>预处理每一个辆车的每一个转折点，以及方向，并且按照时间排序。</p></li><li><p>对于卡车i，绑定与它有查询关系的卡车，保存的时候保证i的转折点要小于与它绑定的其他卡车。显然，如果i的转折点大于某一辆卡车，它会被另外一辆卡车绑定。用这个去优化前面能过一半点的代码。‘</p></li><li><p>取出一个转折点，处理与对应的卡车有查询关系的卡车。</p></li></ol><p>程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> llint;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123; LEFT = <span class="number">-1</span>, ABDUCTED, RIGHT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> truck_id;</span><br><span class="line">  <span class="keyword">int</span> x, direction;</span><br><span class="line">  llint time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> truck_id, was_left, query_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">truck</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="keyword">int</span> x, direction;</span><br><span class="line">  llint time;</span><br><span class="line">  <span class="built_in">vector</span>&lt;query&gt; queries;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">truck trucks[MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_event</span><span class="params">(<span class="keyword">const</span> event &amp;e)</span> </span>&#123;</span><br><span class="line">  trucks[e.truck_id].x = e.x;</span><br><span class="line">  trucks[e.truck_id].direction = e.direction;</span><br><span class="line">  trucks[e.truck_id].time = e.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_is_left</span><span class="params">(<span class="keyword">const</span> truck &amp;a, <span class="keyword">const</span> truck &amp;b, llint prev_time,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> prev_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b.direction == ABDUCTED &amp;&amp; prev_time &gt;= b.time)</span><br><span class="line">    <span class="keyword">return</span> ABDUCTED;</span><br><span class="line">  <span class="keyword">int</span> b_pos, a_pos;</span><br><span class="line">  <span class="keyword">if</span> (b.direction == ABDUCTED) &#123;</span><br><span class="line">    b_pos = b.x;</span><br><span class="line">    a_pos = (a.time - b.time) * (-prev_direction) + a.x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a_pos = a.x;</span><br><span class="line">    b_pos = (a.time - b.time) * b.direction + b.x;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(b_pos != a_pos);</span><br><span class="line">  <span class="keyword">if</span> (b_pos &lt; a_pos)</span><br><span class="line">    <span class="keyword">return</span> LEFT;</span><br><span class="line">  <span class="keyword">return</span> RIGHT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_query</span><span class="params">(<span class="keyword">const</span> truck &amp;t, query &amp;q, llint prev_time,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> prev_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> is_left = check_is_left(t, trucks[q.truck_id], prev_time, prev_direction);</span><br><span class="line">  ans[q.query_id] += (q.was_left * is_left == <span class="number">-1</span>);</span><br><span class="line">  q.was_left = is_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> event &amp;a, <span class="keyword">const</span> event &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.time != b.time)</span><br><span class="line">    <span class="keyword">return</span> a.time &lt; b.time;</span><br><span class="line">  <span class="keyword">return</span> a.direction &gt; b.direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;event&gt; events;</span><br><span class="line">  <span class="built_in">map</span>&lt;pii, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; same_queries;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    llint sum_time = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;trucks[i].k, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; trucks[i].k - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> new_x;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;new_x);</span><br><span class="line">      event e = &#123;i, x, x &lt; new_x ? RIGHT : LEFT, sum_time&#125;;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">        apply_event(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        events.push_back(e);</span><br><span class="line">      &#125;</span><br><span class="line">      sum_time += <span class="built_in">abs</span>(x - new_x);</span><br><span class="line">      x = new_x;</span><br><span class="line">    &#125;</span><br><span class="line">    event e = &#123;i, x, ABDUCTED, sum_time&#125;;</span><br><span class="line">    events.push_back(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    --a;</span><br><span class="line">    --b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      swap(a, b);</span><br><span class="line">    same_queries[&#123;a, b&#125;].push_back(i);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)same_queries[&#123;a, b&#125;].size() &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (trucks[a].k &gt; trucks[b].k)</span><br><span class="line">      swap(a, b);</span><br><span class="line">    trucks[a].queries.push_back(</span><br><span class="line">        &#123;b, trucks[b].x &lt; trucks[a].x ? LEFT : RIGHT, i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  sort(events.begin(), events.end(), cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> event &amp;e : events) &#123;</span><br><span class="line">    llint prev_time = trucks[e.truck_id].time;</span><br><span class="line">    <span class="keyword">int</span> prev_direction = trucks[e.truck_id].direction;</span><br><span class="line">    apply_event(e);</span><br><span class="line">    <span class="keyword">for</span> (query &amp;q : trucks[e.truck_id].queries)</span><br><span class="line">      solve_query(trucks[e.truck_id], q, prev_time, prev_direction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> queries : same_queries) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = ans[queries.second[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t : queries.second)</span><br><span class="line">      ans[t] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GXOI/GZOI2019-lvxingzhe</title>
      <link href="/2019/09/22/GXOI-GZOI2019-lvxingzhe/"/>
      <url>/2019/09/22/GXOI-GZOI2019-lvxingzhe/</url>
      
        <content type="html"><![CDATA[<h3 id="暴力："><a href="#暴力：" class="headerlink" title="暴力："></a>暴力：</h3><p>对于每个特殊点为起始点计算Dijkstra或spfa。。</p><p>然而这样有很多重复操作，很多路径会被重复走。</p><h3 id="改善："><a href="#改善：" class="headerlink" title="改善："></a>改善：</h3><p>考虑把特殊点分组，分组只计算两组间的最短路，组内不计算。显然，分为两组最优（如果分为多组的话其实和没有分组一样会走重复路径）。最方便的分组方法就是把特殊点编号转为二进制，第$i$次分组，将第$i$位为$1$的分一组，其余另一组。共需分$\log n$次组。</p><p>为获得每一次分组的最短路，我们利用类似于网络流建图的方法。将$s$连向一组的所有点无向边，边权为$0$，将另一组的所有点连向$t$无向边，边权为$0$，$s$到$t$的最短路和$t$到$s$的最短路的最小值就是这一次分组的最短路结果。最终结果为所有分组最短路的最小值。</p><a id="more"></a><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memset0(x, s) memset(x, 0, sizeof(int) * (s + 2))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next                                                                   \</span></span><br><span class="line">  ___________________________________________________________________________________________________</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>, MAXM = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, to, next;</span><br><span class="line">  ll w;</span><br><span class="line">&#125; edge[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  ll dis;</span><br><span class="line">  node(<span class="keyword">int</span> tid, ll tdis) &#123;</span><br><span class="line">    id = tid;</span><br><span class="line">    dis = tdis;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;B) <span class="keyword">const</span> &#123; <span class="keyword">return</span> dis &gt; B.dis; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll dis1[MAXN], dis2[MAXN], ans;</span><br><span class="line"><span class="keyword">int</span> head1[MAXN], head2[MAXN], id[MAXN], from1[MAXN], from2[MAXN], n, m, k, tot;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">  edge[++tot] = (Edge)&#123;u, v, head1[u], w&#125;, head1[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">  edge[++tot] = (Edge)&#123;u, v, head2[u], w&#125;, head2[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;node&gt; q;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    q.pop();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    dis1[i] = INF, vis[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    dis1[id[i]] = <span class="number">0l</span>l, from1[id[i]] = id[i], q.push(node(id[i], <span class="number">0l</span>l));</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    node cur = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">int</span> u = cur.id;</span><br><span class="line">    <span class="keyword">if</span> (vis[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head1[u]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[e].to;</span><br><span class="line">      <span class="keyword">if</span> (dis1[v] &gt; dis1[u] + edge[e].w)</span><br><span class="line">        dis1[v] = dis1[u] + edge[e].w, from1[v] = from1[u],</span><br><span class="line">        q.push(node(v, dis1[v]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  priority_queue&lt;node&gt; q;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    q.pop();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    dis2[i] = INF, vis[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    dis2[id[i]] = <span class="number">0l</span>l, from2[id[i]] = id[i], q.push(node(id[i], <span class="number">0l</span>l));</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    node cur = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">int</span> u = cur.id;</span><br><span class="line">    <span class="keyword">if</span> (vis[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head2[u]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[e].to;</span><br><span class="line">      <span class="keyword">if</span> (dis2[v] &gt; dis2[u] + edge[e].w)</span><br><span class="line">        dis2[v] = dis2[u] + edge[e].w, from2[v] = from2[u],</span><br><span class="line">        q.push(node(v, dis2[v]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span> (; T; --T) &#123;</span><br><span class="line">    memset0(head1, n), memset0(head2, n), memset0(edge, m &lt;&lt; <span class="number">1</span>),</span><br><span class="line">        tot = <span class="number">0</span>, ans = INF, <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w), addedge1(u, v, w), addedge2(v, u, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, id + i);</span><br><span class="line">    dij1(), dij2();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m &lt;&lt; <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = edge[i].u, v = edge[i].to;</span><br><span class="line">      ll w = edge[i].w;</span><br><span class="line">      <span class="keyword">if</span> (from1[u] != from2[v])</span><br><span class="line">        ans = min(ans, dis1[u] + w + dis2[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GXOI/GZOI2019-旧词</title>
      <link href="/2019/09/22/GXOI-GZOI2019-jiuci/"/>
      <url>/2019/09/22/GXOI-GZOI2019-jiuci/</url>
      
        <content type="html"><![CDATA[<h3 id="相关链接（雾：-LNOI2014-LCA"><a href="#相关链接（雾：-LNOI2014-LCA" class="headerlink" title="相关链接（雾：[LNOI2014]LCA"></a>相关链接（雾：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3626" target="_blank" rel="noopener">[LNOI2014]LCA</a></h3><p>实际上这题就是加了一个幂。。<del>原题爆破比赛</del></p><a id="more"></a><h3 id="原题-当-k-1-时"><a href="#原题-当-k-1-时" class="headerlink" title="原题:当$k=1$时"></a>原题:当$k=1$时</h3><p>暴力：求LCA再求深度。。然后观察一下求LCA的方法。。最暴力的方法就是把根节点到节点$i$的路径上的点都打上标记，然后由节点$y$往上，直到一个有标记的点为止。。</p><p>然而这题并不需要求LCA的序号，只需要深度，于是对于每个询问中$[1,x]$的每个节点$i$，把上面打标记换成权值$+1$，把扫到一个有标记的点为止变为统计根节点到节点$y$的路径上节点的权值和。。</p><p>然后我们发现每个询问中中的节点可以一起做，于是这就变成了树链剖分的模版。。</p><h3 id="当-k-not-1-时"><a href="#当-k-not-1-时" class="headerlink" title="当$k\not=1$时"></a>当$k\not=1$时</h3><p>先观察$k=1$时，点的权值其实是$(dep_i)^1-(dep_i-1)^1=1$</p><p>于是，当$k\not=1$时，点权就是$(dep_i)^k-(dep_i-1)^k=1$。当然，处理这个的时候要预处理一下。。其他的和$k=1$时一样。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (n &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (n &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next                                                                   \</span></span><br><span class="line">  ___________________________________________________________________________________________________</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50004</span>, MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, K, f[MAXN], x, y, value[MAXN], size[MAXN], h, head[MAXN], dep[MAXN],</span><br><span class="line">    v[MAXN], cnt, t[MAXN &lt;&lt; <span class="number">2</span>], k[MAXN &lt;&lt; <span class="number">2</span>], delta[MAXN &lt;&lt; <span class="number">2</span>], id[MAXN],</span><br><span class="line">    nid[MAXN], top[MAXN], son[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; g[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, id;</span><br><span class="line">&#125; s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  g[++h].next = head[x], head[x] = h, g[h].to = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">      s = <span class="number">1L</span>L * s * a % MOD;</span><br><span class="line">    a = <span class="number">1L</span>L * a * a % MOD, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = delta[n];</span><br><span class="line">  delta[n] = <span class="number">0</span>, t[lson] = (t[lson] + <span class="number">1L</span>L * x * k[lson]) % MOD,</span><br><span class="line">  t[rson] = (t[rson] + <span class="number">1L</span>L * x * k[rson]) % MOD,</span><br><span class="line">  delta[lson] = (delta[lson] + x) % MOD, delta[rson] = (delta[rson] + x) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j, maxs = <span class="number">-1</span>;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].next) &#123;</span><br><span class="line">    j = g[i].to;</span><br><span class="line">    <span class="keyword">if</span> (dep[j])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    dep[j] = dep[x] + <span class="number">1</span>, dfs1(j), size[x] += size[j];</span><br><span class="line">    <span class="keyword">if</span> (size[j] &gt;= maxs)</span><br><span class="line">      son[x] = j, maxs = size[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ttop)</span> </span>&#123;</span><br><span class="line">  top[x] = ttop, id[x] = ++cnt, nid[cnt] = x;</span><br><span class="line">  <span class="keyword">if</span> (!son[x])</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  dfs2(son[x], ttop);</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = g[i].next) &#123;</span><br><span class="line">    j = g[i].to;</span><br><span class="line">    <span class="keyword">if</span> (j == son[x] || j == f[x])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    dfs2(j, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(data a, data b)</span> </span>&#123; <span class="keyword">return</span> a.x &lt; b.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x += y;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= MOD)</span><br><span class="line">    x -= MOD;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>)(k[n] = v[nid[l]], t[n] = delta[n] = <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  build(lson, l, mid), build(rson, mid + <span class="number">1</span>, r), t[n] = add(t[lson], t[rson]),</span><br><span class="line">                                                k[n] = add(k[lson], k[rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">    <span class="keyword">return</span> t[n];</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (delta[n])</span><br><span class="line">    pushdown(n);</span><br><span class="line">  <span class="keyword">if</span> (ll &lt;= mid)</span><br><span class="line">    ans = query(lson, l, mid, ll, rr);</span><br><span class="line">  <span class="keyword">if</span> (rr &gt; mid)</span><br><span class="line">    ans = add(ans, query(rson, mid + <span class="number">1</span>, r, ll, rr));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>)(t[n] = add(t[n], k[n]), delta[n] = add(delta[n], <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (delta[n])</span><br><span class="line">    pushdown(n);</span><br><span class="line">  <span class="keyword">if</span> (ll &lt;= mid)</span><br><span class="line">    update(lson, l, mid, ll, rr);</span><br><span class="line">  <span class="keyword">if</span> (rr &gt; mid)</span><br><span class="line">    update(rson, mid + <span class="number">1</span>, r, ll, rr);</span><br><span class="line">  t[n] = add(t[lson], t[rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">      swap(x, y);</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">1</span>, n, id[top[y]], id[y]), y = f[top[y]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">    swap(x, y);</span><br><span class="line">  update(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[top[x]] &gt; dep[top[y]])</span><br><span class="line">      swap(x, y);</span><br><span class="line">    ans = add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[y]], id[y])), y = f[top[y]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y])</span><br><span class="line">    swap(x, y);</span><br><span class="line">  ans = add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;q, &amp;K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i]), addedge(f[i], i);</span><br><span class="line">  dep[<span class="number">1</span>] = <span class="number">1</span>, dfs1(<span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    value[i] = qpow(dep[i], K);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    v[i] = (value[i] - value[f[i]] + MOD) % MOD;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i].x, &amp;s[i].y), s[i].id = i;</span><br><span class="line">  sort(s + <span class="number">1</span>, s + <span class="number">1</span> + q, cmp), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= s[i].x &amp;&amp; l &lt;= n)</span><br><span class="line">      change(<span class="number">1</span>, l), l++;</span><br><span class="line">    ans[s[i].id] = solve(<span class="number">1</span>, s[i].y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF55E-Very-Simple-Problem</title>
      <link href="/2019/09/22/CF55E-Very-Simple-Problem/"/>
      <url>/2019/09/22/CF55E-Very-Simple-Problem/</url>
      
        <content type="html"><![CDATA[<p>讲道理的话，题目中有<strong>simple</strong>一词的题目都不会简单。。</p><p>这道题如果我们直接计算包含的个数，本蒟蒻只能想到$O(n^3)$的解法，然后就咕咕了。。于是我们可以从反面考虑——数不包含该点的三角形。然后我们发现，如果一个三角形不包含该点，则这个三角形总有一条边把该点和三角形另一个顶点分割开了，于是我们只需要枚举线段那个分割线段，然后求三角形另一个顶点有多少种选法即可，最后用总数减一下。</p><a id="more"></a><p>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; a[<span class="number">2</span> * MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dis</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x1, <span class="keyword">long</span> <span class="keyword">long</span> y1, <span class="keyword">long</span> <span class="keyword">long</span> x2, <span class="keyword">long</span> <span class="keyword">long</span> y2,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> <span class="keyword">long</span> x3, <span class="keyword">long</span> <span class="keyword">long</span> y3)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x2 - x1) * (y3 - y2) - (y2 - y1) * (x3 - x2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">in_poly</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> area1 = <span class="number">0</span>, area2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    area1 += a[i].first * a[i + <span class="number">1</span>].second - a[i].second * a[i + <span class="number">1</span>].first;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    area2 += <span class="built_in">fabs</span>(</span><br><span class="line">        dis(x, y, a[i].first, a[i].second, a[i + <span class="number">1</span>].first, a[i + <span class="number">1</span>].second));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fabs</span>(area) == area2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L * x * (x - <span class="number">1</span>) * (x - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L * x * (x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!in_poly(x, y, n))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; dis(a[i].first, a[i].second, a[j + <span class="number">1</span>].first, a[j + <span class="number">1</span>].second, x, y) &lt;</span><br><span class="line">           <span class="number">0</span>;</span><br><span class="line">         ++j)</span><br><span class="line">      ;</span><br><span class="line">    sum += C2(j - i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> C3(n) - sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    a[i + n] = a[i];</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(x, y, n) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF75E-Ship&#39;s-Shortest-Path</title>
      <link href="/2019/09/22/CF75E-Ship-s-Shortest-Path/"/>
      <url>/2019/09/22/CF75E-Ship-s-Shortest-Path/</url>
      
        <content type="html"><![CDATA[<p>计算几何方法存点、算边来建图，然后跑一边最短路就行了。这题水到Floyd都能过。。。</p><p>我们先连接起始点(s)和终点(t)。如果st不与多边形相交或与多边形的一条边重合，则直接输出st的长度。否则，建一个由s、t、st与多边形的两个交点、多边形的端点组成的图。若这张图中有两点为端点的线段不与多边形相交，则这两个点之间建一条边权为从一点走到另一点费用的边。最后求s、t两点的最短路即可。</p><a id="more"></a><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define cross(a, b) ((conj(a) * (b)).imag())</span><br><span class="line">#define X real()</span><br><span class="line">#define Y imag()</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef complex&lt;double&gt; point;</span><br><span class="line"></span><br><span class="line">const double eps = 1e-9;</span><br><span class="line"></span><br><span class="line">int cmp(double a, double b) &#123;</span><br><span class="line">  if (fabs(a - b) &lt; eps)</span><br><span class="line">    return 0;</span><br><span class="line">  return a &gt; b ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct set_cmp &#123;</span><br><span class="line">  bool operator()(const point &amp;A, const point &amp;B) const &#123;</span><br><span class="line">    if (cmp(A.X, B.X))</span><br><span class="line">      return A.X &lt; B.X;</span><br><span class="line">    if (cmp(A.Y, B.Y))</span><br><span class="line">      return A.Y &lt; B.Y;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double len(point A, point B) &#123; return hypot(A.X - B.X, A.Y - B.Y); &#125;</span><br><span class="line"></span><br><span class="line">bool segement(point A, point B, point R) &#123;</span><br><span class="line">  return cmp(len(A, B), len(A, R) + len(B, R)) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool inter(point A, point B, point P, point Q, point &amp;R) &#123;</span><br><span class="line">  double d1 = cross(P - A, B - A);</span><br><span class="line">  double d2 = cross(Q - A, B - A);</span><br><span class="line">  if (cmp(d1, d2) == 0)</span><br><span class="line">    return false;</span><br><span class="line">  R = (d1 * Q - d2 * P) / (d1 - d2);</span><br><span class="line">  if (!segement(A, B, R) || !segement(P, Q, R))</span><br><span class="line">    return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">point st, en;</span><br><span class="line">vector&lt;point&gt; pol;</span><br><span class="line"></span><br><span class="line">double g[34][34];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  st = point(x, y);</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  en = point(x, y);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    pol.push_back(point(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  double ans = len(st, en);</span><br><span class="line">  set&lt;point, set_cmp&gt; intrs;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    point R;</span><br><span class="line">    if (inter(st, en, pol[i], pol[(i + 1) % n], R))</span><br><span class="line">      intrs.insert(R);</span><br><span class="line">  &#125;</span><br><span class="line">  if (intrs.size() == 2) &#123;</span><br><span class="line">    point p1 = *intrs.begin();</span><br><span class="line">    point p2 = *(++intrs.begin());</span><br><span class="line">    for (int i = 0; i &lt; n + 4; i++) &#123;</span><br><span class="line">      for (int j = 0; j &lt; n + 4; j++)</span><br><span class="line">        g[i][j] = 1 &lt;&lt; 30;</span><br><span class="line">      g[i][i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cmp(len(p2, st), len(p1, st)) &lt; 0)</span><br><span class="line">      swap(p1, p2);</span><br><span class="line">    g[0][2] = g[2][0] = len(st, p1);</span><br><span class="line">    g[1][3] = g[3][1] = len(en, p2);</span><br><span class="line">    g[2][3] = g[3][2] = len(p1, p2) * 2;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      int i1 = i + 4;</span><br><span class="line">      int i2 = (i + 1) % n + 4;</span><br><span class="line">      g[i1][i2] = g[i2][i1] = len(pol[i1 - 4], pol[i2 - 4]);</span><br><span class="line">      if (segement(pol[i1 - 4], pol[i2 - 4], p1)) &#123;</span><br><span class="line">        if (segement(pol[i1 - 4], pol[i2 - 4], p2))</span><br><span class="line">          return printf(&quot;%.9lf\n&quot;, ans), 0;</span><br><span class="line">        g[2][i1] = g[i1][2] = len(pol[i1 - 4], p1);</span><br><span class="line">        g[2][i2] = g[i2][2] = len(pol[i2 - 4], p1);</span><br><span class="line">      &#125;</span><br><span class="line">      if (segement(pol[i1 - 4], pol[i2 - 4], p2)) &#123;</span><br><span class="line">        g[3][i1] = g[i1][3] = len(pol[i1 - 4], p2);</span><br><span class="line">        g[3][i2] = g[i2][3] = len(pol[i2 - 4], p2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n += 4;</span><br><span class="line">    for (int k = 0; k &lt; n; k++)</span><br><span class="line">      for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">    ans = g[0][1];</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%.9lf\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF46G-Emperor&#39;s-Problem</title>
      <link href="/2019/09/22/CF46G-Emperor-s-Problem/"/>
      <url>/2019/09/22/CF46G-Emperor-s-Problem/</url>
      
        <content type="html"><![CDATA[<p>CodeForces的标签中说这题是计算几何题，，，而官方题解里说这是贪心题，，，然而我认为这就是一道暴力题。。</p><a id="more"></a><p>设有两个点$(x_1,y_1)$和$(x_2,y_2)$，则这条边的长$l=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$，那么$l^2=(x_1-x_2)^2+(y_1-y_2)^2$。我们定义{X,Y}为这条边的移动量，则$\{X,Y\}=\{x_1-x_2,y_1-y_2\}$。所以有$X^2+Y^2=l^2$。</p><p>假设有一个n边形，则有$\{\sum_{i=1}^{i=n}X_i,\sum_{i=1}^{i=n}Y_i\}=\{0,0\}$，所以$\sum_{i=1}^{i=n}(X_i)^2$和$\sum_{i=1}^{i=n}(Y_i)^2$皆为偶数，所以$\sum_{i=1}^{i=n}(l_i)^2$为偶数。</p><p>于是我们可以假设有一点为(0,0),第一条边为最长边。从4开始穷举$l^2$(因为1,2,3是不可能作为$l^2$)，我们知道从(0,0)为一个端点，选另一个整数格点作为另一个端点且线段长度为l的线段最多有8个，我们可以任意选一个线段作为第一条边，于是$X_1$和$Y_1$便就已知了。然后就转化为了一个更简单的问题：已知$X_1$和$Y_1$的值，求$\left\{\begin{matrix} \sum_{i=2}^{i=n}X_i=-X_1 \  \sum_{i=2}^{i=n}Y_i=-Y_1 \ l_{i(2\le i\le n)}\le l_1 \end{matrix}\right.$的一组解。这个可以配合奇偶性快速求出。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct point &#123;</span><br><span class="line">  int x, y, r;</span><br><span class="line">  point() &#123;&#125;</span><br><span class="line">  point(int a, int b) : x(a), y(b), r(a * a + b * b) &#123;&#125;</span><br><span class="line">  bool operator==(point &amp;cmp) const &#123; return r == cmp.r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;point&gt; vec;</span><br><span class="line">vector&lt;pair&lt;int, int&gt;&gt; X, Y;</span><br><span class="line"></span><br><span class="line">bool cmp1(const point &amp;a, const point &amp;b) &#123; return a.r &lt; b.r; &#125;</span><br><span class="line">bool cmp2(const point &amp;a, const point &amp;b) &#123;</span><br><span class="line">  return atan2(a.y + 0.0, a.x + 0.0) &lt; atan2(b.y + 0.0, b.x + 0.0) - 1e-8;</span><br><span class="line">&#125;</span><br><span class="line">void init() &#123;</span><br><span class="line">  for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    for (int j = i; j &lt; 200; j++) &#123;</span><br><span class="line">      vec.push_back(point(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(vec.begin(), vec.end(), cmp1);</span><br><span class="line">  vec.erase(unique(vec.begin(), vec.end()), vec.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  ios_base::sync_with_stdio(false);</span><br><span class="line">  init();</span><br><span class="line">  int n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  int del = 0;</span><br><span class="line">  for (int i = 4, cnt = 2, bit = 1;; i++) &#123;</span><br><span class="line">    int p = bit;</span><br><span class="line">    int q = (vec[i].x + vec[i].y) &amp; 1;</span><br><span class="line">    if (p &amp;&amp; q) &#123;</span><br><span class="line">      if (++cnt == n)</span><br><span class="line">        del = 3;</span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125; else if (p &amp;&amp; !q) &#123;</span><br><span class="line">      if (++cnt == n)</span><br><span class="line">        del = 6;</span><br><span class="line">    &#125; else if (!p &amp;&amp; !q)</span><br><span class="line">      ++cnt;</span><br><span class="line">    bit = (p + q) &amp; 1;</span><br><span class="line">    if (cnt &gt;= n) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">        if (j == del)</span><br><span class="line">          continue;</span><br><span class="line">        X.push_back(make_pair(vec[j].x, X.size()));</span><br><span class="line">        Y.push_back(make_pair(vec[j].y, Y.size()));</span><br><span class="line">        sum = (sum + vec[j].x) &amp; 1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (sum &amp; 1)</span><br><span class="line">        swap(X[0].first, Y[0].first);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(X.begin(), X.end());</span><br><span class="line">  sort(Y.begin(), Y.end());</span><br><span class="line">  int sumX = 0, sumY = 0;</span><br><span class="line">  for (int i = X.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">    if (abs(sumX - X[i].first) &lt; abs(sumX + X[i].first)) &#123;</span><br><span class="line">      sumX -= X[i].first;</span><br><span class="line">      X[i].first = -X[i].first;</span><br><span class="line">    &#125; else</span><br><span class="line">      sumX += X[i].first;</span><br><span class="line">    if (abs(sumY - Y[i].first) &lt; abs(sumY + Y[i].first)) &#123;</span><br><span class="line">      sumY -= Y[i].first;</span><br><span class="line">      Y[i].first = -Y[i].first;</span><br><span class="line">    &#125; else</span><br><span class="line">      sumY += Y[i].first;</span><br><span class="line">  &#125;</span><br><span class="line">  while (sumX || sumY)</span><br><span class="line">    ;</span><br><span class="line">  for (int i = 0; i &lt; X.size(); i++) &#123;</span><br><span class="line">    vec[X[i].second].x = X[i].first;</span><br><span class="line">    vec[Y[i].second].y = Y[i].first;</span><br><span class="line">  &#125;</span><br><span class="line">  vec.erase(vec.begin() + X.size(), vec.end());</span><br><span class="line">  sort(vec.begin(), vec.end(), cmp2);</span><br><span class="line">  cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">  int sumx = 0, sumy = 0;</span><br><span class="line">  for (int i = 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    sumx += vec[i].x;</span><br><span class="line">    sumy += vec[i].y;</span><br><span class="line">    cout &lt;&lt; sumx &lt;&lt; &apos; &apos; &lt;&lt; sumy &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF87E-Mogohu-Rea-Idol</title>
      <link href="/2019/09/22/CF87E-Mogohu-Rea-Idol/"/>
      <url>/2019/09/22/CF87E-Mogohu-Rea-Idol/</url>
      
        <content type="html"><![CDATA[<p>题解是真的简单。。。就是对三个凸包求$Minkowski sum$，然后判断点是否在凸多边形内即可。。。</p><p>这题竟然还保证一个多边形内三点不共线。。。于是判断一个点是否在一个多边形边上变得更简单。。。一开始竟然没有看到这个条件，在那里进行检查。。。</p><p>最后，在代码前略微解释一下$Minkowski sum$,其实就是$A+B=\{a+b|a∈A,b∈B\}$</p><a id="more"></a><p>上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct hull &#123;</span><br><span class="line">  map&lt;int, int&gt; points;</span><br><span class="line">  long long area;</span><br><span class="line">  inline hull() &#123;</span><br><span class="line">    points.clear();</span><br><span class="line">    area = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  inline map&lt;int, int&gt;::iterator prev(map&lt;int, int&gt;::iterator it) &#123;</span><br><span class="line">    return it == points.begin() ? it : --it;</span><br><span class="line">  &#125;</span><br><span class="line">  inline map&lt;int, int&gt;::iterator next(map&lt;int, int&gt;::iterator it) &#123;</span><br><span class="line">    return it == points.end() ? it : ++it;</span><br><span class="line">  &#125;</span><br><span class="line">  inline long long traparea(long long x1, long long y1, long long x2,</span><br><span class="line">                            long long y2) &#123;</span><br><span class="line">    return (x2 - x1) * (y1 + y2);</span><br><span class="line">  &#125;</span><br><span class="line">  inline long long triarea(long long x1, long long y1, long long x2,</span><br><span class="line">                           long long y2, long long x3, long long y3) &#123;</span><br><span class="line">    return traparea(x1, y1, x2, y2) + traparea(x2, y2, x3, y3) +</span><br><span class="line">           traparea(x3, y3, x1, y1);</span><br><span class="line">  &#125;</span><br><span class="line">  inline long long traparea(map&lt;int, int&gt;::iterator a,</span><br><span class="line">                            map&lt;int, int&gt;::iterator b) &#123;</span><br><span class="line">    return traparea(a-&gt;first, a-&gt;second, b-&gt;first, b-&gt;second);</span><br><span class="line">  &#125;</span><br><span class="line">  inline long long triarea(map&lt;int, int&gt;::iterator it) &#123;</span><br><span class="line">    long long sum = 0;</span><br><span class="line">    if (it != points.begin())</span><br><span class="line">      sum += traparea(prev(it), it);</span><br><span class="line">    if (next(it) != points.end())</span><br><span class="line">      sum += traparea(it, next(it));</span><br><span class="line">    if (it != points.begin() &amp;&amp; next(it) != points.end())</span><br><span class="line">      sum += traparea(next(it), prev(it));</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">  inline bool bad(map&lt;int, int&gt;::iterator it) &#123;</span><br><span class="line">    if (points.size() &lt; 3 || it == points.begin() || next(it) == points.end())</span><br><span class="line">      return false;</span><br><span class="line">    return triarea(it) &lt;= 0;</span><br><span class="line">  &#125;</span><br><span class="line">  inline void insert(int x, int y) &#123;</span><br><span class="line">    if (points.find(x) != points.end()) &#123;</span><br><span class="line">      if (y &lt;= points[x])</span><br><span class="line">        return;</span><br><span class="line">      area -= triarea(points.lower_bound(x));</span><br><span class="line">      points.erase(x);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;int, int&gt;::iterator it = points.insert(make_pair(x, y)).first;</span><br><span class="line">    if (bad(it)) &#123;</span><br><span class="line">      points.erase(it);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    area += triarea(it);</span><br><span class="line">    while (bad(prev(it))) &#123;</span><br><span class="line">      area -= triarea(prev(it));</span><br><span class="line">      points.erase(prev(it));</span><br><span class="line">    &#125;</span><br><span class="line">    while (bad(next(it))) &#123;</span><br><span class="line">      area -= triarea(next(it));</span><br><span class="line">      points.erase(next(it));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  inline bool contains(int x, int y) &#123;</span><br><span class="line">    map&lt;int, int&gt;::iterator first = points.begin(), last = prev(points.end());</span><br><span class="line">    if (x &lt; first-&gt;first || x &gt; last-&gt;first)</span><br><span class="line">      return false;</span><br><span class="line">    if (x == first-&gt;first)</span><br><span class="line">      return y &lt;= first-&gt;second;</span><br><span class="line">    if (x == last-&gt;first)</span><br><span class="line">      return y &lt;= last-&gt;second;</span><br><span class="line">    map&lt;int, int&gt;::iterator it = points.lower_bound(x), p = prev(it);</span><br><span class="line">    int x1 = p-&gt;first, y1 = p-&gt;second, x2 = it-&gt;first, y2 = it-&gt;second;</span><br><span class="line">    return (long long)(y - y1) * (x2 - x1) &lt;= (long long)(x - x1) * (y2 - y1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef complex&lt;int&gt; point;</span><br><span class="line">typedef vector&lt;point&gt; polygon;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; inline pair&lt;T, T&gt; to_pair(complex&lt;T&gt; x) &#123;</span><br><span class="line">  return make_pair(x.real(), x.imag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline long long cross(point a, point b) &#123;</span><br><span class="line">  return (long long)a.real() * b.imag() - (long long)b.real() * a.imag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polygon minkowski_sum(polygon a, polygon b) &#123;</span><br><span class="line">  int n = a.size(), m = b.size();</span><br><span class="line">  int aind = -1, bind = -1;</span><br><span class="line">  for (int i = 0; i &lt; n; i++)</span><br><span class="line">    if (aind == -1 || to_pair(a[i]) &lt; to_pair(a[aind]))</span><br><span class="line">      aind = i;</span><br><span class="line">  for (int i = 0; i &lt; m; i++)</span><br><span class="line">    if (bind == -1 || to_pair(b[i]) &lt; to_pair(b[bind]))</span><br><span class="line">      bind = i;</span><br><span class="line">  polygon sum;</span><br><span class="line">  sum.reserve(n + m);</span><br><span class="line">  bool alooped = false, blooped = false;</span><br><span class="line">  int i = aind, j = bind;</span><br><span class="line">  while (!(i == aind &amp;&amp; alooped) || !(j == bind &amp;&amp; blooped)) &#123;</span><br><span class="line">    point pa = a[(i + 1) % n] - a[i], pb = b[(j + 1) % m] - b[j];</span><br><span class="line">    if (!(i == aind &amp;&amp; alooped) &amp;&amp;</span><br><span class="line">        ((j == bind &amp;&amp; blooped) || cross(pa, pb) &gt; 0)) &#123;</span><br><span class="line">      sum.push_back(a[i] + b[j] + pa);</span><br><span class="line">      i = (i + 1) % n;</span><br><span class="line">      alooped |= i == 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      sum.push_back(a[i] + b[j] + pb);</span><br><span class="line">      j = (j + 1) % m;</span><br><span class="line">      blooped |= j == 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">polygon A, B, C;</span><br><span class="line"></span><br><span class="line">void input(polygon &amp;P) &#123;</span><br><span class="line">  int n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">  for (int x, y, i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</span><br><span class="line">    P.push_back(point(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hull upper, lower;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  input(A);</span><br><span class="line">  input(B);</span><br><span class="line">  input(C);</span><br><span class="line">  polygon X = minkowski_sum(A, B);</span><br><span class="line">  X = minkowski_sum(X, C);</span><br><span class="line">  for (int i = 0; i &lt; (int)X.size(); i++) &#123;</span><br><span class="line">    upper.insert(X[i].real(), X[i].imag());</span><br><span class="line">    lower.insert(X[i].real(), -X[i].imag());</span><br><span class="line">  &#125;</span><br><span class="line">  int M;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;M);</span><br><span class="line">  for (int x, y, i = 0; i &lt; M; i++) &#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</span><br><span class="line">    puts(upper.contains(3 * x, 3 * y) &amp;&amp; lower.contains(3 * x, -3 * y) ? &quot;YES&quot;</span><br><span class="line">                                                                       : &quot;NO&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF82E-Corridor</title>
      <link href="/2019/09/22/CF82E-Corridor/"/>
      <url>/2019/09/22/CF82E-Corridor/</url>
      
        <content type="html"><![CDATA[<p>这屑题可能是计算几何题中的难得的良心题了。。。这题其实就是灯照进去每个窗的面积总和减去灯光相交、重叠部分的面积。</p><a id="more"></a><ol><li><p>灯照进去每个窗的面积总和</p><p> 我们很容易发现这题灯照进去每个窗的面积其实就是一个梯形的面积，这个梯形的高就是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 重叠面积</span><br><span class="line"></span><br><span class="line">    重叠部分一般为三角形，但如果有光束的交点的纵坐标在```-h~h```之外时，是梯形。计算面积是用之前求出的函数解析式求出两条边缘光束的交点、边缘光束与x轴的交点，然后计算面积即可。</span><br><span class="line"></span><br><span class="line">最后容斥原理计算一下面积就行了。</span><br><span class="line"></span><br><span class="line">上代码：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define SGN(x) ((x) &gt; eps ? 1 : ((x) &gt; -eps ? 0 : -1))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line">  point() &#123;&#125;</span><br><span class="line">  point(double _x, double _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">  point operator-(const point p1) &#123; return point(x - p1.x, y - p1.y); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double cross(const point &amp;a, const point &amp;b, const point &amp;c) &#123;</span><br><span class="line">  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double cross(const point &amp;a, const point &amp;b) &#123; return a.x * b.y - a.y * b.x; &#125;</span><br><span class="line"></span><br><span class="line">double dot(const point &amp;a, const point &amp;b) &#123; return a.x * b.x + a.y * b.y; &#125;</span><br><span class="line"></span><br><span class="line">point its(const point &amp;a, const point &amp;b, const point &amp;c, const point &amp;d) &#123;</span><br><span class="line">  point ret = a;</span><br><span class="line">  double t = ((c.x - a.x) * (d.y - c.y) - (c.y - a.y) * (d.x - c.x)) /</span><br><span class="line">             ((b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x));</span><br><span class="line">  ret.x += (b.x - a.x) * t;</span><br><span class="line">  ret.y += (b.y - a.y) * t;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">point p[1010][4];</span><br><span class="line"></span><br><span class="line">pair&lt;double, int&gt; e[5000];</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">inline void insert(point &amp;s, point &amp;t, point X, int inc) &#123;</span><br><span class="line">  double ratio =</span><br><span class="line">      SGN(t.x - s.x) ? (X.x - s.x) / (t.x - s.x) : (X.y - s.y) / (t.y - s.y);</span><br><span class="line">  e[cnt++] = make_pair(ratio, inc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double h, f;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;h, &amp;f);</span><br><span class="line">  point p1(0, -f), p2(0, f);</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    double l, r;</span><br><span class="line">    scanf(&quot;%lf%lf&quot;, &amp;l, &amp;r);</span><br><span class="line">    p[i * 2][0] = point(l, -h);</span><br><span class="line">    p[i * 2][1] = point(r, -h);</span><br><span class="line">    p[i * 2][2] = its(p1, point(r, -h), point(0, h), point(100, h));</span><br><span class="line">    p[i * 2][3] = its(p1, point(l, -h), point(0, h), point(100, h));</span><br><span class="line">    p[i * 2 + 1][0] = point(r, h);</span><br><span class="line">    p[i * 2 + 1][1] = point(l, h);</span><br><span class="line">    p[i * 2 + 1][2] = its(p2, point(l, h), point(0, -h), point(100, -h));</span><br><span class="line">    p[i * 2 + 1][3] = its(p2, point(r, h), point(0, -h), point(100, -h));</span><br><span class="line">  &#125;</span><br><span class="line">  n *= 2;</span><br><span class="line">  double ans = 0.0;</span><br><span class="line">  int cp0, cp1, cp2;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">      point &amp;s = p[i][k], &amp;t = p[i][k == 3 ? 0 : k + 1];</span><br><span class="line">      cnt = 0;</span><br><span class="line">      e[cnt++] = make_pair(0.0, 1);</span><br><span class="line">      e[cnt++] = make_pair(1.0, -1);</span><br><span class="line">      for (int j = 0; j &lt; n; j++)</span><br><span class="line">        if (i != j) &#123;</span><br><span class="line">          for (int l = 0; l &lt; 4; l++) &#123;</span><br><span class="line">            cp0 = SGN(cross(s, t, p[j][l == 0 ? 3 : l - 1]));</span><br><span class="line">            cp1 = SGN(cross(s, t, p[j][l]));</span><br><span class="line">            cp2 = SGN(cross(s, t, p[j][l == 3 ? 0 : l + 1]));</span><br><span class="line">            if (cp1 * cp2 &lt; 0)</span><br><span class="line">              insert(s, t, its(s, t, p[j][l], p[j][l == 3 ? 0 : l + 1]), cp2);</span><br><span class="line">            else if (!cp1 &amp;&amp; cp0 * cp2 &lt; 0)</span><br><span class="line">              insert(s, t, p[j][l], cp2);</span><br><span class="line">            else if (!cp1 &amp;&amp; !cp2 &amp;&amp; j &gt; i &amp;&amp;</span><br><span class="line">                     dot(t - s, p[j][l == 3 ? 0 : l + 1] - p[j][l]) &gt; -eps) &#123;</span><br><span class="line">              insert(s, t, p[j][l], -1);</span><br><span class="line">              insert(s, t, p[j][l == 3 ? 0 : l + 1], 1);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      sort(e, e + cnt);</span><br><span class="line">      int acc = 0;</span><br><span class="line">      double total = 0.0, last;</span><br><span class="line">      for (int j = 0; j &lt; cnt; j++) &#123;</span><br><span class="line">        acc += e[j].second;</span><br><span class="line">        if (acc == 0 &amp;&amp; e[j].second &lt; 0)</span><br><span class="line">          total += e[j].first - last;</span><br><span class="line">        last = e[j].first;</span><br><span class="line">      &#125;</span><br><span class="line">      ans += cross(s, t) * total;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%.10lf\n&quot;, ans * 0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF78E-Evacuation</title>
      <link href="/2019/09/22/CF78E-Evacuation/"/>
      <url>/2019/09/22/CF78E-Evacuation/</url>
      
        <content type="html"><![CDATA[<ol><li><p>分析数据</p><p> 我们可以将一个科学家可以在t分钟之内从(x0,y0)移动到(x1,y1)作为(x0,y0)在t时刻联通。</p></li></ol><a id="more"></a><ol><li><p>建图</p><p> 现在我们有一个网格图了，我们可以再将其转化一下。我们构造有一个源点，一个汇点，中间有两个层，每层$n^2$个节点的图。将每个点在开始时的科学家数量作为源点到这个点在第一层相应节点的边的流量。将每个点开始时的胶囊数量作为这个点在第二层所对应的节点到汇点的边的流量。若(x0,y0)和(x1,y1)在某一时刻是联通的，则将(x0,y0)在第一层所对应的节点和(x1,y1)在第二层所对应的节点连一条流量为正无穷的边。</p></li><li><p>求解</p><p> emmm…在我们构建的新图上跑一遍网络最大流，最大流即为答案。然而，根据相关法律法规，网络流题不允许卡Dinic/ISAP/HLPP，但可以卡EK，所以还是别用EK好。</p></li></ol><p>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[maxn][maxn], ss[maxn][maxn], can[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> och[<span class="number">200</span>][<span class="number">2</span>], was[maxn][maxn], n, q[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b, e;</span><br><span class="line">  b = e = <span class="number">1</span>;</span><br><span class="line">  och[b][<span class="number">0</span>] = x;</span><br><span class="line">  och[b][<span class="number">1</span>] = y;</span><br><span class="line">  <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> tx, ty, i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      was[i][j] = <span class="number">-1</span>;</span><br><span class="line">  was[x][y] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &lt;= e) &#123;</span><br><span class="line">    x = och[b][<span class="number">0</span>];</span><br><span class="line">    y = och[b][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (was[x][y] == t) &#123;</span><br><span class="line">      ++b;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      tx = x + dx[i];</span><br><span class="line">      ty = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= n || a[tx][ty] == <span class="string">'Y'</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (was[tx][ty] == <span class="number">-1</span>) &#123;</span><br><span class="line">        was[tx][ty] = was[x][y] + <span class="number">1</span>;</span><br><span class="line">        och[++e][<span class="number">0</span>] = tx;</span><br><span class="line">        och[e][<span class="number">1</span>] = ty;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to;</span><br><span class="line">  <span class="keyword">int</span> cap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> flag[maxn] = &#123;<span class="number">0</span>&#125;, pos[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addE</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  edge ee;</span><br><span class="line">  ee.to = to;</span><br><span class="line">  ee.cap = d;</span><br><span class="line">  e.push_back(ee);</span><br><span class="line">  v[from].push_back(e.size() - <span class="number">1</span>);</span><br><span class="line">  ee.to = from;</span><br><span class="line">  ee.cap = <span class="number">0</span>;</span><br><span class="line">  e.push_back(ee);</span><br><span class="line">  v[to].push_back(e.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t, mn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, reb, u, tmp;</span><br><span class="line">  flag[w] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = pos[w]; i &lt; v[w].size(); i++) &#123;</span><br><span class="line">    reb = v[w][i];</span><br><span class="line">    u = e[reb].to;</span><br><span class="line">    tmp = mn;</span><br><span class="line">    <span class="keyword">if</span> (e[reb].cap &gt; <span class="number">0</span> &amp;&amp; e[reb].cap &lt; mn)</span><br><span class="line">      mn = e[reb].cap;</span><br><span class="line">    <span class="keyword">if</span> (e[reb].cap &gt; <span class="number">0</span> &amp;&amp; (flag[u] == <span class="number">0</span> &amp;&amp; dfs(u))) &#123;</span><br><span class="line">      e[reb].cap -= mn;</span><br><span class="line">      e[reb ^ <span class="number">1</span>].cap += mn;</span><br><span class="line">      pos[w] = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mn = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos[w]; i++) &#123;</span><br><span class="line">    reb = v[w][i];</span><br><span class="line">    u = e[reb].to;</span><br><span class="line">    <span class="keyword">if</span> (e[reb].cap &gt; <span class="number">0</span> &amp;&amp; (flag[u] == <span class="number">0</span> &amp;&amp; dfs(u))) &#123;</span><br><span class="line">      e[reb].cap -= mn;</span><br><span class="line">      e[reb ^ <span class="number">1</span>].cap += mn;</span><br><span class="line">      pos[w] = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, fl = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (fl) &#123;</span><br><span class="line">    fl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= t; i++) &#123;</span><br><span class="line">      flag[i] = <span class="number">0</span>;</span><br><span class="line">      pos[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      mn = inf;</span><br><span class="line">      <span class="keyword">if</span> (!dfs(s))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      fl = <span class="number">1</span>;</span><br><span class="line">      flag[s] = flag[t] = <span class="number">0</span>;</span><br><span class="line">      res += mn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fx, fy;</span><br><span class="line">  fx = x;</span><br><span class="line">  fy = y;</span><br><span class="line">  <span class="keyword">int</span> cap = a[x][y] - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">int</span> b, e;</span><br><span class="line">  b = e = <span class="number">1</span>;</span><br><span class="line">  och[b][<span class="number">0</span>] = x;</span><br><span class="line">  och[b][<span class="number">1</span>] = y;</span><br><span class="line">  <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> tx, ty, i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      q[i][j] = <span class="number">-1</span>;</span><br><span class="line">  q[x][y] = <span class="number">0</span>;</span><br><span class="line">  addE(fx * n + fy, fx * n + fy + n * n, cap);</span><br><span class="line">  <span class="keyword">while</span> (b &lt;= e) &#123;</span><br><span class="line">    x = och[b][<span class="number">0</span>];</span><br><span class="line">    y = och[b][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (q[x][y] == t || q[x][y] == was[x][y]) &#123;</span><br><span class="line">      ++b;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">      tx = x + dx[i];</span><br><span class="line">      ty = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= n || a[tx][ty] == <span class="string">'Z'</span> ||</span><br><span class="line">          a[tx][ty] == <span class="string">'Y'</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (q[tx][ty] == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">          (q[x][y] + <span class="number">1</span> &lt;= was[tx][ty] || was[tx][ty] == <span class="number">-1</span>)) &#123;</span><br><span class="line">        q[tx][ty] = q[x][y] + <span class="number">1</span>;</span><br><span class="line">        addE(fx * n + fy, tx * n + ty + n * n, cap);</span><br><span class="line">        och[++e][<span class="number">0</span>] = tx;</span><br><span class="line">        och[e][<span class="number">1</span>] = ty;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, i, j, x, y;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">      <span class="keyword">if</span> (a[i][j] == <span class="string">'Z'</span>) &#123;</span><br><span class="line">        x = i;</span><br><span class="line">        y = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; ss[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">  bfs(x, y, T);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i][j] &gt;= <span class="string">'0'</span> &amp;&amp; a[i][j] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        bfs2(i, j, T);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s = n * n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  t = n * n * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i][j] &gt;= <span class="string">'0'</span> &amp;&amp; a[i][j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">        addE(s, i * n + j, a[i][j] - <span class="string">'0'</span>);</span><br><span class="line">      <span class="keyword">if</span> (ss[i][j] &gt;= <span class="string">'1'</span> &amp;&amp; ss[i][j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">        addE(i * n + j + n * n, t, ss[i][j] - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> res = flow();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF73F-Plane-of-Tanks</title>
      <link href="/2019/09/22/CF73F-Plane-of-Tanks/"/>
      <url>/2019/09/22/CF73F-Plane-of-Tanks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一眼二分题，check打懵逼   ——某奆佬</p></blockquote><p>好吧，，，在这题中，如果$v_1 \le v_2$且$v_1$为可行解，则$v_2$必然为可行解，所以是有单调性的，所以可以二分，然后二分的check就不会打了。。</p><a id="more"></a><hr><h3 id="重点：关于check"><a href="#重点：关于check" class="headerlink" title="重点：关于check"></a><strong>重点：关于check</strong></h3><ol><li><p>分析</p><p>分析一下，发现我们其实可以假设所有坦克都转向B点（因为如果一个坦克能在Pedalny行驶过程中（包括AB）指向Pedalny，必然能在Pedalny到达B点之前指向B点，于是只要等Pedalny来了之后一起轰击就行了），于是我们只需要计算出Pedalny到达B点之前，有多少坦克能指向B点就行了。为了让更多的坦克指向B点<del>（误</del>，我们需要计算出对于每个坦克，是顺时针旋转指向B点，还是逆时针旋转指向B点快。</p></li><li><p>计算旋转时间</p><p>然后我们发现每个坦克的旋转速度是确定的，于是我们只需要计算旋转角就行了，然后就变成了用勾股定理求出边长，然后使用求直角三角形的角的正切值之后$tan^{-1}$算出角度，然后就解决问题了。</p><p>如图，CD//x轴，坦克C初始面向射线CE方向，BF$\perp$CD，题目给出了$\angle DCF$，我们只需要计算$\angle BCF$即可，具体计算为:$\angle BCF=tan^{-1}(\frac {BF} {CF})$,最终旋转角为$\angle DCF + \angle BCF$</p><p><img src="https://i.loli.net/2018/12/06/5c091f3554115.png" alt="geogebra-export.png"></p></li></ol><p>似乎比官方题解简单多了。。个人写实数二分较为奇怪，请勉强接受一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define EPS 1e-6</span><br><span class="line">#define PI acos(-1)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int n, m, k;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">  double x, y;</span><br><span class="line">  Point() &#123;&#125;</span><br><span class="line">  Point(double x, double y) : x(x), y(y) &#123;&#125;</span><br><span class="line">  double abs() const &#123; return hypot(x, y); &#125;</span><br><span class="line">  double arg() const &#123; return atan2(y, x); &#125;</span><br><span class="line">  Point operator*(double o) const &#123; return Point(x * o, y * o); &#125;</span><br><span class="line">  Point operator+(const Point &amp;o) const &#123; return Point(x + o.x, y + o.y); &#125;</span><br><span class="line">  Point operator-(const Point &amp;o) const &#123; return Point(x - o.x, y - o.y); &#125;</span><br><span class="line">  bool operator&lt;(const Point &amp;o) const &#123;</span><br><span class="line">    return x &lt; o.x - EPS || (x &lt; o.x + EPS &amp;&amp; y &lt; o.y - EPS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point A, B;</span><br><span class="line">map&lt;double, int&gt; js;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(&quot;%lf%lf%lf%lf&quot;, &amp;A.x, &amp;A.y, &amp;B.x, &amp;B.y);</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">  double x, y, a, w;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x, &amp;y, &amp;a, &amp;w);</span><br><span class="line">    if (abs(w) &lt; EPS)</span><br><span class="line">      continue;</span><br><span class="line">    Point p = &#123;x, y&#125;;</span><br><span class="line">    double v = -2;</span><br><span class="line">    for (int j = 0; j &lt;= 100; j++) &#123;</span><br><span class="line">      Point tp = (B - A) * (j / 100.0) + A;</span><br><span class="line">      double arg = (tp - p).arg() - a;</span><br><span class="line">      if (arg &gt; 2 * PI)</span><br><span class="line">        arg -= 2 * PI;</span><br><span class="line">      while (arg &lt; 0)</span><br><span class="line">        arg += 2 * PI;</span><br><span class="line">      if (arg &gt; 2 * PI - arg)</span><br><span class="line">        arg = 2 * PI - arg;</span><br><span class="line">      double t = arg / w;</span><br><span class="line">      v = v &lt; -1 ? (tp - A).abs() / t : max(v, (tp - A).abs() / t);</span><br><span class="line">    &#125;</span><br><span class="line">    js[v]++;</span><br><span class="line">  &#125;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">  int sk = 0;</span><br><span class="line">  double t = -10;</span><br><span class="line">  for (map&lt;double, int&gt;::reverse_iterator it = js.rbegin(); it != js.rend();</span><br><span class="line">       it++) &#123;</span><br><span class="line">    if (sk + it-&gt;second &gt; k) &#123;</span><br><span class="line">      t = it-&gt;first;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    sk += it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%.4lf\n&quot;, t &lt; -1 ? 0 : t);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF512E-Fox-And-Ploygon</title>
      <link href="/2019/09/22/CF512E-Fox-And-Ploygon/"/>
      <url>/2019/09/22/CF512E-Fox-And-Ploygon/</url>
      
        <content type="html"><![CDATA[<p><del>本来以为是一道奇怪的dp题，，，然而发现它不是求最小值，而是求具体方案。。。</del></p><p>有一种思路是这样的：</p><p>将这个被分成许多三角形的多边形映射成一个有根树，其中每个三角形是一个非根、非叶子节点，每条对角线是一条边，根节点和叶子节点都在多边形外。通过旋转该树直到旋转成了目标状态。目标状态可为任何一种构型的树。实际上是<strong>先构造出初始状态下的数，然后以同样的根构造出目标状态下的树，然后旋转、计数</strong>。请允许我用官方题解中的图。</p><a id="more"></a><p><img src="https://puu.sh/e4tiX/db64342636.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; e[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">bool</span> have[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> leftMark, rightMark;</span><br><span class="line">node* sonLeft, *sonRight;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">leftMark = sonLeft-&gt;leftMark;</span><br><span class="line">rightMark = sonRight-&gt;rightMark;</span><br><span class="line">&#125;</span><br><span class="line">&#125;*start, *want;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">step</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fromA, fromB;</span><br><span class="line"><span class="keyword">int</span> toA, toB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">node *t = <span class="keyword">new</span> node();</span><br><span class="line">t-&gt;leftMark = L;</span><br><span class="line">t-&gt;rightMark = R;</span><br><span class="line"><span class="keyword">if</span>(L == R+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[L].size(); i++)</span><br><span class="line"><span class="keyword">if</span>(e[L][i] != from)</span><br><span class="line">have[e[L][i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> M = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; e[R].size(); j++)</span><br><span class="line"><span class="keyword">if</span>(e[R][j] != from)</span><br><span class="line"><span class="keyword">if</span>(have[e[R][j]])</span><br><span class="line">M = e[R][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[L].size(); i++)</span><br><span class="line">have[e[L][i]] = <span class="literal">false</span>;</span><br><span class="line">t-&gt;sonLeft = addNode(L, M, R);</span><br><span class="line">t-&gt;sonRight = addNode(M, R, L);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">e[i].clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">e[a].push_back(b);</span><br><span class="line">e[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i == n) j = <span class="number">1</span>;</span><br><span class="line">e[i].push_back(j);</span><br><span class="line">e[j].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addNode(n, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node *p, <span class="built_in">string</span> append)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; append &lt;&lt; p-&gt;leftMark &lt;&lt; <span class="string">" "</span> &lt;&lt; p-&gt;rightMark &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;sonLeft != <span class="literal">NULL</span>)</span><br><span class="line">print(p-&gt;sonLeft, append + <span class="string">"\t"</span>);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;sonRight != <span class="literal">NULL</span>)</span><br><span class="line">print(p-&gt;sonRight, append + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;step&gt; record;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateR</span><span class="params">(node *r)</span> </span>&#123;</span><br><span class="line">step t;</span><br><span class="line">node *s = r-&gt;sonLeft;</span><br><span class="line">node *a = s-&gt;sonLeft;</span><br><span class="line">node *b = s-&gt;sonRight;</span><br><span class="line">node *c = r-&gt;sonRight;</span><br><span class="line">t.fromA = s-&gt;leftMark;</span><br><span class="line">t.fromB = s-&gt;rightMark;</span><br><span class="line">r-&gt;sonLeft = a;</span><br><span class="line">r-&gt;sonRight = s;</span><br><span class="line">s-&gt;sonLeft = b;</span><br><span class="line">s-&gt;sonRight = c;</span><br><span class="line">s-&gt;updateMark();</span><br><span class="line">r-&gt;updateMark();</span><br><span class="line">t.toA = s-&gt;leftMark;</span><br><span class="line">t.toB = s-&gt;rightMark;</span><br><span class="line">record.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateL</span><span class="params">(node *r)</span> </span>&#123;</span><br><span class="line">step t;</span><br><span class="line">node *s = r-&gt;sonRight;</span><br><span class="line">node *a = r-&gt;sonLeft;</span><br><span class="line">node *b = s-&gt;sonLeft;</span><br><span class="line">node *c = s-&gt;sonRight;</span><br><span class="line">t.fromA = s-&gt;leftMark;</span><br><span class="line">t.fromB = s-&gt;rightMark;</span><br><span class="line">r-&gt;sonLeft = s;</span><br><span class="line">r-&gt;sonRight = c;</span><br><span class="line">s-&gt;sonLeft = a;</span><br><span class="line">s-&gt;sonRight = b;</span><br><span class="line">s-&gt;updateMark();</span><br><span class="line">r-&gt;updateMark();</span><br><span class="line">t.toA = s-&gt;leftMark;</span><br><span class="line">t.toB = s-&gt;rightMark;</span><br><span class="line">record.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateRT</span><span class="params">(node *p, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> myMiddle = p-&gt;sonLeft-&gt;rightMark;</span><br><span class="line"><span class="keyword">if</span>(myMiddle == middle)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(myMiddle &lt; middle) &#123;</span><br><span class="line">rotateRT(p-&gt;sonLeft, middle);</span><br><span class="line">rotateR(p);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(myMiddle &gt; middle) &#123;</span><br><span class="line">rotateRT(p-&gt;sonRight, middle);</span><br><span class="line">rotateL(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">norm</span><span class="params">(node *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;leftMark - p-&gt;rightMark &lt;= <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> middle = (p-&gt;leftMark + p-&gt;rightMark) / <span class="number">2</span>;</span><br><span class="line">rotateRT(p, middle);</span><br><span class="line">norm(p-&gt;sonLeft);</span><br><span class="line">norm(p-&gt;sonRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios :: sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span>(have));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">start = input();</span><br><span class="line">norm(start);</span><br><span class="line"><span class="built_in">vector</span> &lt;step&gt; record1 = record;</span><br><span class="line">record.clear();</span><br><span class="line">want = input();</span><br><span class="line">norm(want);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; record.size() + record1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; record1.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; record1[i].fromA &lt;&lt; <span class="string">" "</span> &lt;&lt; record1[i].fromB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = record.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; record[i].toA &lt;&lt; <span class="string">" "</span> &lt;&lt; record[i].toB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>好烦啊QAQ</del></p><p>然而还有一种简单而暴力的思路：</p><p>我们只需要进行一系列的变换使初始状态中所有的对角线变成以1号节点为端点的对角线并正序存储变换的步骤，然后在进行一系列变换使目标状态中所有的对角线也变成以1号节点为端点的对角线并<strong>倒序存储</strong>变换的步骤（毕竟这实际上是倒推），记一下总数并输出步骤即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; vii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> e[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">flip</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">bool</span> inv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">-1</span>, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (e[a][i] &amp;&amp; e[b][i])</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">-1</span>)</span><br><span class="line">        x = i;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        y = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  e[a][b] = e[b][a] = <span class="literal">false</span>;</span><br><span class="line">  e[x][y] = e[y][x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> inv ? make_pair(x, y) : make_pair(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vii <span class="title">solve</span><span class="params">(<span class="keyword">bool</span> inv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    e[i][(i + <span class="number">1</span>) % n] = e[(i + <span class="number">1</span>) % n][i] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, a, b; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    a--;</span><br><span class="line">    b--;</span><br><span class="line">    e[a][b] = e[b][a] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vii res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e[<span class="number">0</span>][i]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; e[<span class="number">0</span>][j] == <span class="number">0</span>; j++)</span><br><span class="line">      ;</span><br><span class="line">    res.push_back(flip(i - <span class="number">1</span>, j, inv));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  vii a = solve(<span class="literal">false</span>), b = solve(<span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a.size() + b.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a.size(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i].first + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a[i].second + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i].first + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b[i].second + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>明显简单了许多</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF54E-Vacuum-Cleaner</title>
      <link href="/2019/09/15/C-F54E-acuum-%D0%A1leaner/"/>
      <url>/2019/09/15/C-F54E-acuum-%D0%A1leaner/</url>
      
        <content type="html"><![CDATA[<p>简洁的题意翻译：对于一个凸包形状的吸尘器，问你这个吸尘器在清理矩形的角落时，遗留下的最小面积，可以旋转</p><p><del>都翻译成这样了，明显</del><strong>这题需要计算几何</strong></p><a id="more"></a><p><img src="https://i.loli.net/2018/11/25/5bfa412598c34.png" alt="tmp.png"></p><p>如图，死角的面积是$S_{\Delta ABC}-S_1$(注：1可为任何边形)，明显，对于每个固定的A和B，$S_1$的面积是固定的且$\Delta ABC$的高AB也是固定的。于是，<strong>为了让死角面积最小，就是让$\Delta ABC$AB边上的高最小</strong>。因为直角三角形的斜边的中线等于斜边的一半，所以点O在以AB为直径的圆上，所以<strong>当三角形的边与多边形的边重合时高最小</strong>。</p><p>于是我们只需要枚举该多边形的n条边，讨论其靠左墙或靠下墙，然后通过作垂直于该边的线求出贴在另一墙上离点O最近的点，然后计算出此时面积，取最小值。维护内部多边形的面积时可将其分割成若干三角形，然后用叉积维护。</p><p>最后，注意精度控制</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long sqr(long long x) __attribute__((always_inline));</span><br><span class="line"></span><br><span class="line">long long sqr(long long x) &#123; return x * x; &#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">  Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;</span><br><span class="line">  inline Point &amp;operator-=(const Point &amp;o) &#123;</span><br><span class="line">    x -= o.x;</span><br><span class="line">    y -= o.y;</span><br><span class="line">    return *this;</span><br><span class="line">  &#125;</span><br><span class="line">  double dis() const __attribute__((always_inline));</span><br><span class="line">  int x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double Point::dis() const &#123; return sqrt(sqr(x) + sqr(y)); &#125;</span><br><span class="line"></span><br><span class="line">inline Point operator-(Point a, const Point &amp;b) &#123; return a -= b; &#125;</span><br><span class="line"></span><br><span class="line">long long det(const Point &amp;a, const Point &amp;b) __attribute__((always_inline));</span><br><span class="line">long long dot(const Point &amp;a, const Point &amp;b) __attribute__((always_inline));</span><br><span class="line">long long get_sum(int i, int j) __attribute__((always_inline));</span><br><span class="line">int nxt(int i) __attribute__((always_inline));</span><br><span class="line">double solve() __attribute__((always_inline));</span><br><span class="line"></span><br><span class="line">long long det(const Point &amp;a, const Point &amp;b) &#123;</span><br><span class="line">  return (long long)a.x * b.y - (long long)a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long dot(const Point &amp;a, const Point &amp;b) &#123;</span><br><span class="line">  return (long long)a.x * b.x + (long long)a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int N = 40000;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">Point p[N];</span><br><span class="line">long long sum[N + 1];</span><br><span class="line"></span><br><span class="line">long long get_sum(int i, int j) &#123;</span><br><span class="line">  long long s = sum[j] - sum[i];</span><br><span class="line">  return i &lt;= j ? s : sum[n] + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int nxt(int i) &#123; return (i + 1) % n; &#125;</span><br><span class="line"></span><br><span class="line">double solve() &#123;</span><br><span class="line">  sum[0] = 0;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    sum[i + 1] = sum[i] + det(p[i], p[(i + 1) % n]);</span><br><span class="line">  double result = INFINITY;</span><br><span class="line">  for (int i = 0, j = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    while (dot(p[nxt(i)] - p[i], p[nxt(j)] - p[j]) &gt; 0)</span><br><span class="line">      j = nxt(j);</span><br><span class="line">    Point a = p[nxt(i)] - p[i];</span><br><span class="line">    Point b = p[j] - p[i];</span><br><span class="line">    double n = a.dis();</span><br><span class="line">    result = min(result, det(a, b) / n * dot(a, b) / n -</span><br><span class="line">                             (get_sum(i, j) + det(p[j], p[i])));</span><br><span class="line">    if (i == j)</span><br><span class="line">      return 0.;</span><br><span class="line">  &#125;</span><br><span class="line">  return .5 * result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">  for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">  solve();</span><br><span class="line">  if (sum[n] &lt; 0)</span><br><span class="line">    reverse(p, p + n);</span><br><span class="line">  double result = solve();</span><br><span class="line">  for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    p[i].x *= -1;</span><br><span class="line">  reverse(p, p + n);</span><br><span class="line">  result = min(result, solve());</span><br><span class="line">  printf(&quot;%.10f\n&quot;, result);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/15/hello-world/"/>
      <url>/2019/09/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
